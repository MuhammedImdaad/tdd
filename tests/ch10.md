# Chapter 10: Additional TDD Concepts and Discussions
learned the core of TDD: the TDD cycle, basic TDD concepts, construction guidelines, how to create and use test doubles, design considerations, how to code quality tests, and how to tackle legacy challenges and concurrency. Not everything always fits into a neat little package.

* TDD and Performance - you should seek optimal design before you attempt to address performance concerns. From a (unit-level) test-driven standpoint, you will almost never have the knowledge up front for performance evaluation. Run the performance tests on a machine with the same characteristics as the production target. don’t assume anything. Always measure before and after. Get the design right first, and only then introduce optimizations. compilers today are very smart beasts, able to optimize code in many cases better than you ever could by hand. With larger functions, you actually decrease the compiler’s chances to optimize code.
* Unit Tests, Integration Tests, and Acceptance Tests - TDD is a programmer practice to help you incrementally drive the design of code. ​unit​ means a small piece of isolated logic that affects some systematic behavior. unit tests are inadequate. Since they verify small isolated pieces of code, they can’t demonstrate the correctness of an end-to-end deployed-and-configured solution.  customer tests are any tests defined to demonstrate that the software meets business needs. Agile proponents will often refer to customer tests defined up front as​ acceptance tests​(ATs). integration tests are difficult to maintain. best off if you code only as many integration tests as you absolutely need, and no more. the audiences and goals for each set of tests are different. No one else will ever read your programmer tests. The acceptance tests, in contrast, are designed to be read by anyone. Defects represent an incorrect or missing unit test. You correct defects by following a test-driven approach.
* The Transformation Priority Premise (TPP) - Success with TDD requires the ability to grow a system by small increments. a tool for determining your next test is Robert C. Martin’s ​Transformation Priority Premise (TPP)​, which proposes a priority list of transformations, [https://web.archive.org/web/20130113152824/http://cleancoder.posterous.com/the-transformation-priority-premise]. TDD without the disciplined add-on of the TPP works well enough, But adopt the TPP, and you’ll do more than survive—you’ll thrive.
* Writing Assertions First - in order of Assert-Act-Arrange, a potentially better approach is to write the assertion first. If this is a struggle, perhaps you don’t have enough information yet to continue writing the test.

TDD vs BDD - 
In practice, a team might use BDD to define features and acceptance criteria in feature files. These acceptance criteria then guide the developers in writing their TDD unit tests to implement the functionality correctly. The automated BDD scenarios serve as higher-level integration or acceptance tests, verifying that the system behaves as expected from an end-user perspective.